<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing</title>
    <script src="https://cdn.jsdelivr.net/npm/midi-parser-js@4.0.4/src/main.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .back-button {
            background: rgba(212, 175, 55, 0.2);
            border: 2px solid #d4af37;
            color: #d4af37;
            padding: 12px 24px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Georgia', serif;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 30px;
        }

        .back-button:hover {
            background: #d4af37;
            color: #1a1a2e;
            transform: translateX(-5px);
        }

        .player-container {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
        }

        .piece-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .piece-title {
            font-size: 2.5em;
            color: #d4af37;
            margin-bottom: 15px;
            font-weight: 400;
        }

        .piece-composer {
            font-size: 1.5em;
            color: #b8b8b8;
            font-style: italic;
            margin-bottom: 10px;
        }

        .piece-info {
            font-size: 1em;
            color: #999;
        }

        .visualization-container {
            margin: 40px 0;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(212, 175, 55, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 300px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #d4af37, #f4cf67);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .progress-bar:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #b8b8b8;
            font-variant-numeric: tabular-nums;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 30px 0;
        }

        .control-button {
            background: rgba(212, 175, 55, 0.2);
            border: 2px solid #d4af37;
            color: #d4af37;
            padding: 15px 30px;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Georgia', serif;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-button:hover:not(:disabled) {
            background: #d4af37;
            color: #1a1a2e;
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .like-section {
            text-align: center;
            margin-top: 30px;
        }

        .like-button-large {
            background: none;
            border: 3px solid #d4af37;
            color: #d4af37;
            padding: 15px 40px;
            font-size: 1.5em;
            cursor: pointer;
            border-radius: 50px;
            font-family: 'Georgia', serif;
            transition: all 0.3s ease;
        }

        .like-button-large:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.05);
        }

        .like-button-large.liked {
            background: #d4af37;
            color: #1a1a2e;
        }

        .status {
            text-align: center;
            font-size: 1.2em;
            color: #d4af37;
            margin: 20px 0;
            min-height: 30px;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 1.5em;
            color: #d4af37;
        }

        .loading-spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 4px solid rgba(212, 175, 55, 0.3);
            border-top-color: #d4af37;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="#" id="backButton" class="back-button">← Back to Composer</a>

        <div id="content">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading piece...</p>
            </div>
        </div>
    </div>

    <script>
        const midiPath = decodeURIComponent("{{ midi_path }}");
        let midiOutput = null;
        let midiData = null;
        let isPlaying = false;
        let currentTime = 0;
        let totalDuration = 0;
        let animationFrameId = null;
        let playbackStartTime = 0;
        let pausedAt = 0;
        let noteSchedules = [];
        let activeTimeouts = [];
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let bufferLength = 0;
        let composerName = '';
        let pieceData = null;

        // Initialize
        async function init() {
            try {
                // Load piece info first
                await loadPieceInfo();

                // Load MIDI data
                const response = await fetch(`/api/maestro-midi/${midiPath}`);
                const arrayBuffer = await response.arrayBuffer();

                // Parse MIDI using midi-parser-js
                const uint8Array = new Uint8Array(arrayBuffer);
                midiData = MidiParser.parse(uint8Array);

                // Calculate duration
                calculateDuration();

                // Initialize MIDI output
                await initMIDI();

                // Initialize audio context for visualization
                initAudioContext();

            } catch (error) {
                console.error('Error initializing:', error);
                document.getElementById('status').textContent = 'Error loading piece: ' + error.message;
            }
        }

        function calculateDuration() {
            // Use piece data duration if available
            if (pieceData && pieceData.duration) {
                totalDuration = pieceData.duration;
                return;
            }

            // Otherwise calculate from MIDI data
            let maxTime = 0;
            const ticksPerBeat = midiData.timeDivision;
            let microsecondsPerBeat = 500000; // Default tempo (120 BPM)

            midiData.track.forEach(track => {
                let trackTick = 0;
                let currentTempo = microsecondsPerBeat;

                track.event.forEach(event => {
                    trackTick += event.deltaTime || 0;

                    // Check for tempo changes
                    if (event.type === 255 && event.metaType === 81 && event.data) {
                        currentTempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                    }

                    // Convert to seconds
                    const timeInSeconds = (trackTick / ticksPerBeat) * (currentTempo / 1000000);
                    maxTime = Math.max(maxTime, timeInSeconds);
                });
            });

            totalDuration = maxTime || 60;
        }

        async function loadPieceInfo() {
            try {
                const composersRes = await fetch('/api/composers');
                const composers = await composersRes.json();

                // Find composer and piece from MIDI path
                for (const [name, data] of Object.entries(composers)) {
                    const piece = data.pieces.find(p => p.midi_file === midiPath);
                    if (piece) {
                        composerName = name;
                        pieceData = piece;
                        break;
                    }
                }

                if (!composerName) {
                    composerName = 'Unknown';
                    pieceData = { title: midiPath, year: '', duration: 0 };
                }

                displayPiece();
            } catch (error) {
                console.error('Error loading piece info:', error);
                composerName = 'Unknown';
                pieceData = { title: midiPath, year: '', duration: 0 };
                displayPiece();
            }
        }

        function displayPiece() {
            document.getElementById('backButton').href = `/composer/${encodeURIComponent(composerName)}`;

            const html = `
                <div class="player-container">
                    <div class="piece-header">
                        <h1 class="piece-title">${pieceData.title}</h1>
                        <p class="piece-composer">${composerName}</p>
                        <p class="piece-info">Year: ${pieceData.year} | Duration: ${formatDuration(pieceData.duration || totalDuration)}</p>
                    </div>

                    <div class="visualization-container">
                        <canvas id="visualizer"></canvas>
                    </div>

                    <div class="progress-bar" id="progressBar" onclick="seekTo(event)">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="time-display">
                        <span id="currentTime">0:00</span>
                        <span id="totalTime">${formatDuration(pieceData.duration || totalDuration)}</span>
                    </div>

                    <div class="status" id="status">Ready to play</div>

                    <div class="controls">
                        <button class="control-button" id="playButton" onclick="playMIDI()">Play</button>
                        <button class="control-button" id="pauseButton" onclick="pauseMIDI()" disabled>Pause</button>
                        <button class="control-button" id="stopButton" onclick="stopMIDI()">Stop</button>
                    </div>

                    <div class="like-section">
                        <button class="like-button-large ${isLiked(composerName, pieceData.title) ? 'liked' : ''}"
                                id="likeButton" onclick="toggleLike()">
                            ${isLiked(composerName, pieceData.title) ? '♥ Liked' : '♡ Like'}
                        </button>
                    </div>
                </div>
            `;

            document.getElementById('content').innerHTML = html;

            // Start visualization
            startVisualization();
        }

        async function initMIDI() {
            try {
                const access = await navigator.requestMIDIAccess();
                const outputs = Array.from(access.outputs.values());

                if (outputs.length > 0) {
                    midiOutput = outputs[0];
                    console.log('MIDI Output connected:', midiOutput.name);
                } else {
                    console.warn('No MIDI output devices found');
                }
            } catch (error) {
                console.error('MIDI access error:', error);
            }
        }

        // Track active notes for visualization
        let activeNotes = new Set();
        let noteHistory = [];
        const MAX_HISTORY = 100;

        function initAudioContext() {
            // Initialize Web Audio API for potential future use
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        function addNoteToVisualization(noteNumber, velocity) {
            activeNotes.add(noteNumber);
            noteHistory.push({
                note: noteNumber,
                velocity: velocity,
                time: performance.now()
            });
            if (noteHistory.length > MAX_HISTORY) {
                noteHistory.shift();
            }
        }

        function removeNoteFromVisualization(noteNumber) {
            activeNotes.delete(noteNumber);
        }

        function playMIDI() {
            if (isPlaying || !midiData) return;

            isPlaying = true;
            playbackStartTime = performance.now() - (pausedAt * 1000);

            document.getElementById('playButton').disabled = true;
            document.getElementById('pauseButton').disabled = false;
            document.getElementById('status').textContent = 'Playing...';

            scheduleAllNotes();
            updateProgress();
        }

        function pauseMIDI() {
            if (!isPlaying) return;

            isPlaying = false;
            pausedAt = currentTime;

            // Clear all scheduled timeouts
            activeTimeouts.forEach(timeout => clearTimeout(timeout));
            activeTimeouts = [];

            stopAllNotes();

            document.getElementById('playButton').disabled = false;
            document.getElementById('pauseButton').disabled = true;
            document.getElementById('status').textContent = 'Paused';
        }

        function stopMIDI() {
            isPlaying = false;
            currentTime = 0;
            pausedAt = 0;

            // Clear all scheduled timeouts
            activeTimeouts.forEach(timeout => clearTimeout(timeout));
            activeTimeouts = [];

            stopAllNotes();

            document.getElementById('playButton').disabled = false;
            document.getElementById('pauseButton').disabled = true;
            document.getElementById('status').textContent = 'Stopped';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('currentTime').textContent = '0:00';
        }

        function seekTo(event) {
            const progressBar = document.getElementById('progressBar');
            const rect = progressBar.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const percentage = x / rect.width;
            const newTime = percentage * totalDuration;

            // Stop current playback
            const wasPlaying = isPlaying;
            if (isPlaying) {
                pauseMIDI();
            }

            // Set new time
            pausedAt = newTime;
            currentTime = newTime;

            // Update UI
            document.getElementById('progressFill').style.width = (percentage * 100) + '%';
            document.getElementById('currentTime').textContent = formatDuration(newTime);

            // Resume if was playing
            if (wasPlaying) {
                playMIDI();
            }
        }

        function scheduleAllNotes() {
            if (!midiOutput || !midiData) return;

            const ticksPerBeat = midiData.timeDivision;
            let currentTempo = 500000; // Default 120 BPM (microseconds per beat)

            // Convert all events to absolute time
            const allEvents = [];

            midiData.track.forEach((track, trackIndex) => {
                let trackTick = 0;
                let trackTempo = currentTempo;

                track.event.forEach(event => {
                    trackTick += event.deltaTime || 0;

                    // Update tempo if this is a tempo change event
                    if (event.type === 255 && event.metaType === 81 && event.data) {
                        trackTempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                    }

                    // Convert ticks to seconds
                    const timeInSeconds = (trackTick / ticksPerBeat) * (trackTempo / 1000000);

                    allEvents.push({
                        time: timeInSeconds,
                        type: event.type,
                        metaType: event.metaType,
                        data: event.data,
                        trackIndex: trackIndex
                    });
                });
            });

            // Sort events by time
            allEvents.sort((a, b) => a.time - b.time);

            // Schedule events
            allEvents.forEach(event => {
                const timeInSeconds = event.time;

                // Only schedule events after current position
                if (timeInSeconds < pausedAt) return;

                const delay = (timeInSeconds - pausedAt) * 1000; // Convert to milliseconds

                if (event.type === 9 && event.data && event.data.length >= 2) {
                    // Note On
                    const noteNumber = event.data[0];
                    const velocity = event.data[1];

                    if (velocity > 0) {
                        const timeout = setTimeout(() => {
                            if (midiOutput && isPlaying) {
                                midiOutput.send([0x90, noteNumber, velocity]);
                                addNoteToVisualization(noteNumber, velocity);
                            }
                        }, delay);
                        activeTimeouts.push(timeout);
                    } else {
                        // Note Off (velocity 0)
                        const timeout = setTimeout(() => {
                            if (midiOutput && isPlaying) {
                                midiOutput.send([0x80, noteNumber, 0]);
                                removeNoteFromVisualization(noteNumber);
                            }
                        }, delay);
                        activeTimeouts.push(timeout);
                    }
                } else if (event.type === 8 && event.data && event.data.length >= 1) {
                    // Note Off
                    const noteNumber = event.data[0];

                    const timeout = setTimeout(() => {
                        if (midiOutput && isPlaying) {
                            midiOutput.send([0x80, noteNumber, 0]);
                            removeNoteFromVisualization(noteNumber);
                        }
                    }, delay);
                    activeTimeouts.push(timeout);
                }
            });

            console.log(`Scheduled ${activeTimeouts.length} MIDI events`);
        }

        function stopAllNotes() {
            if (midiOutput) {
                // Send All Notes Off
                for (let i = 0; i < 128; i++) {
                    midiOutput.send([0x80, i, 0]);
                }
            }

            // Clear visualization
            activeNotes.clear();
            noteHistory = [];
        }

        function updateProgress() {
            if (!isPlaying) return;

            const now = (performance.now() - playbackStartTime) / 1000;
            currentTime = now;

            const progress = Math.min((currentTime / totalDuration) * 100, 100);
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('currentTime').textContent = formatDuration(currentTime);

            if (currentTime < totalDuration) {
                requestAnimationFrame(updateProgress);
            } else {
                stopMIDI();
                document.getElementById('status').textContent = 'Finished';
            }
        }

        function startVisualization() {
            const canvas = document.getElementById('visualizer');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = 300;

            const PIANO_RANGE = 88; // 88 keys
            const LOWEST_NOTE = 21; // A0

            function draw() {
                requestAnimationFrame(draw);

                // Background
                ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const now = performance.now();

                // Draw note history (fading particles)
                ctx.globalAlpha = 0.6;
                noteHistory.forEach((note, index) => {
                    const age = now - note.time;
                    const maxAge = 2000; // 2 seconds
                    if (age > maxAge) return;

                    const alpha = 1 - (age / maxAge);
                    const notePosition = (note.note - LOWEST_NOTE) / PIANO_RANGE;
                    const x = notePosition * canvas.width;
                    const y = canvas.height / 2 + Math.sin(age / 200) * 30;
                    const size = (note.velocity / 127) * 20;

                    const hue = notePosition * 60 + 40; // Gold to yellow
                    ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;

                    ctx.beginPath();
                    ctx.arc(x, y, size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1.0;

                // Draw active notes spectrum (bottom)
                const barWidth = canvas.width / PIANO_RANGE;
                activeNotes.forEach(noteNumber => {
                    const notePosition = noteNumber - LOWEST_NOTE;
                    if (notePosition < 0 || notePosition >= PIANO_RANGE) return;

                    const x = notePosition * barWidth;
                    const barHeight = canvas.height * 0.4;

                    const hue = (notePosition / PIANO_RANGE) * 60 + 40;

                    // Gradient bar
                    const gradient = ctx.createLinearGradient(x, canvas.height, x, canvas.height - barHeight);
                    gradient.addColorStop(0, `hsla(${hue}, 90%, 60%, 1)`);
                    gradient.addColorStop(1, `hsla(${hue}, 90%, 50%, 0.3)`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth - 2, barHeight);

                    // Glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `hsla(${hue}, 90%, 60%, 0.8)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth - 2, barHeight);
                    ctx.shadowBlur = 0;
                });

                // Draw waveform-like effect (top)
                if (activeNotes.size > 0) {
                    ctx.strokeStyle = '#d4af37';
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    const amplitude = activeNotes.size * 10;
                    const frequency = 0.01;

                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height * 0.2 + Math.sin(x * frequency + now * 0.005) * amplitude;
                        if (x === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#d4af37';
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Clean up old note history
                noteHistory = noteHistory.filter(note => now - note.time < 2000);
            }

            draw();
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Like functionality
        function getLikes() {
            const likes = localStorage.getItem('classical_likes');
            return likes ? JSON.parse(likes) : {};
        }

        function setLikes(likes) {
            localStorage.setItem('classical_likes', JSON.stringify(likes));
        }

        function isLiked(composer, title) {
            const likes = getLikes();
            const key = `${composer}::${title}`;
            return likes[key] || false;
        }

        function toggleLike() {
            const likes = getLikes();
            const key = `${composerName}::${pieceData.title}`;
            likes[key] = !likes[key];
            setLikes(likes);

            const button = document.getElementById('likeButton');
            button.textContent = likes[key] ? '♥ Liked' : '♡ Like';
            button.classList.toggle('liked', likes[key]);
        }

        // Start on page load
        init();
    </script>
</body>
</html>
